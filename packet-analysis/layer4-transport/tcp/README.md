# TCP
- Transport Layer
- 연결형 통신
- UDP 와 마찬가지로, 포트 번호를 이용하여 **프로세스 대 프로세스 통신**을 제공
- UDP 와 다르게, **스트림 기반 프로토콜**

### UDP / TCP
### UDP 송신 프로세스
1. 프로세스는 미리 정해진 크기 이내의 메시지를 만들고 배달을 위해 UDP 로 보낸다.
2. UDP는 이러한 메시지 각각에 자신의 헤더를 붙인 후(UDP헤더) 전송을 위하여 IP 패킷에게 전달한다.
3. 캡슐화 계속 진행

### TCP 
- 바이트 스트림의 형태로 데이터를 전송할 수 있고, 수신 프로세스도 바이트 스트림의 형태로 데이터를 수신할 수 있다.
- TCP 에서는 두 개의 프로세스가 가상의 `튜브`로 연결되어 있다.
- 송신 및 수신 프로세스가 동일한 데이터를 생성하거나 소비하지 않을 수 있으므로, TCP 에서는 데이터를 전달하기 위한 `버퍼`가 필요하다.
  - 송신 버퍼, 수신 버퍼로 2개가 존재한다.
  - 버퍼는 흐름 및 오류 제어 매커니즘에서도 사용된다.
> TCP는 데이터 전송 시 세그먼트를 여러 개로 분할하여 전송하고, 이를 통해 데이터 전송의 신뢰성과 속도를 높일 수 있다.




### TCP 헤더
![tcp header.png](img%2Ftcp%20header.png)
- `Source port address` : 16비트, 세그먼트를 전송하는 호스트에 있는 응용 프로그램의 포트 번호를 정의
  - UDP 헤더에 있는 발신지 포트 주소와 동일한 목적을 제공


- `Destination port address` : 16비트, 세그먼트를 수신하는 호스트에 있는 응용 프로램의 포트 번호를 정의
  - UDP 헤더에 있는 목적지 포트 주소와 동일한 목적을 제공


- `Sequence number` : 32비트, 세그먼트에 포함된 데이터의 첫 번째 바이트에 부여된 번호를 나타낸다.
  - TCP는 신뢰성 있는 연결을 위하여 전달되는 각 바이트마다 번호를 부여한다.
  - `Sequence number`는 목적지 TCP 에게 세그먼트의 첫 번째 바이트가 이 번호에 해당하는 바이트라는 것을 알려준다.


- `Acknowledgement number` : 32비트, 세그먼트를 수신한 수신 노드가 상대편 노드로부터 수신하고자 하는 바이트의 번호를 정의
  - 만일 세그먼트를 수신한 수신 노드가 상대 노드로부터 바이트 번호 x를 성공적으로 수신했다면, 수신자는 확인응답 번호로 x+1 을 정의


- `HELN` : 4비트, 헤더 길이. 마찬가지로 필드의 값에 *4를 해서 구한다.


- `Reserved` : 6비트, 차후 사용을 위해 예약된 필드


- `Flag(제어)` : 6개의 서로 다른 제어 비트 또는 플래그를 나타낸다.
  - 동시에 여러 개의 비트가 1로 설정될 수 있다.
  - `URG`(Urgent) : 긴급 비트
  - `ACK`(Acknowledgment) : 승인 비트
  - `PSH`(Request for push) : 푸시 비트
  - `RST`(Reset the connection) : 초기화 비트
  - `SYN`(Synchronize sequence numbers) : 동기화 비트
  - `FIN`(Terminate the connection) : 종료비트

- `Windows size` :  16비트, 한 번에 받을 수 있는 패킷 크기를 의미한다.
  - 16비트이므로 윈도우의 최대 크기는 65,535바이트 이다.
  - 윈도우의 크기는 rwnd 라고 하며 수신측에 의해서 결정된다.
  - 이 경우 송신측은 수신측의 지시에 따라야 한다.


- `Checksum` : 16비트, 오류 검사에 이용


- `Urgent pointer`(긴급 포인터) : 16비트, urgent flag가 1로 설정되어 있는 경우에만 유효한 필드
  - 세그먼트가 긴급 데이터를 포함하고 있을 때 사용


- `Option` : 최대 40바이트까지의 옵션 정보가 있을 수 있다.


### 캡슐화
![tcp 캡슐화.png](img%2Ftcp%20%EC%BA%A1%EC%8A%90%ED%99%94.png)


### 3-way handshake
[기본 이론](https://github.com/royroyee/gonet/tree/main/03-layer/04-transport-layer#tcp-3-way-handshake)
1. 클라이언트는 첫 번째 세그먼트로서 `SYN` 플래그가 1로 설정된 `SYN 세그먼트` 를 전송한다.
   - 이 세그먼트는 순서 번호의 동기화가 목적이다.
   - 랜덤한 초기 시퀀스 번호(seq)를 할당
   - 이 세그먼트에는 확인 응답, 윈도우 크기 등이 정의되지 않으며 어떠한 데이터도 전달하지 않는다.
   - 하지만, 하나의 Sequence number(순서 번호)만 소비한다.

2. 서버는 두 번째 세그먼트로서 `SYN` 과 `ACK` 플래그 비트가 각각 1로 설정된 `SYN+ACK` 세그먼트를 전송한다.
  - `SYN 세그먼트` : 반대 방향으로의 통신을 위한 세그먼트. 
    - 서버는 서버로부터 클라이언트로 전송되는 바이트의 순서화를 위한 순서 번호를 초기화하기 위하여 이 세그먼트를 사용한다.
  - `ACK 세그먼트` : 클라이언트로부터 수신하기를 기대하는 다음 순서 번호를 표시함으로써 클라이언트로부터의 SYN 세그먼트 수신을 확인 응답한다.
  - 이 세그먼트는 확인응답 번호를 포함하고 있으며, 윈도우 크기도 포함한다.
  - 랜덤한 초기 시퀀스 번호(seq)를 할당하고, 확인 응답 번호(ack)는 클라이언트의 시퀀스 번호(seq) + 1 로 설정

3. 클라이언트는 세 번째 세그먼트인 `ACK 세그먼트` 를 보낸다.
   - 이 세그먼트는 ACK 플래그와 확인 응답 번호 필드를 이용하여 두 번째 세그먼트의 수신을 확인한다.
   - 자신이 초기화할 때 할당한 시퀀스 번호(seq) + 1을 확인 응답 번호(ack)로 설정

### 간단한 예시
1. Flag : SYN, Sequence number : 8000 , Acknowledgment number : 0
   - Sequence number : 랜덤한 초기 번호 설정
   - Acknowledgment number : 정의되지 않으므로 0이 설정된다.


2. Flag :SYN+ACK, Sequence number: 15000, Acknowledgment number : 8001
    - Sequence number : 랜덤한 초기 번호 설정
    - Acknowledgment number : 클라이언트의 시퀀스 번호 + 1 로 설정

3. Flag : ACK, Sequence number : 8001, Acknowledgment number: 15001
   - Sequence number : ACK 세그먼트는 순서 번호를 소비하지 않으므로 동일한 값이 배정된다.
   - Acknowledgment number : 위와 동일하게 시퀀스 번호 + 1로 설정

---


## 데이터 전송
연결이 설정된 후에는 양 방향으로 데이터가 전송될 수 있다. 클라이언트와 서버는 양 방향으로 데이터와 확인 응답을 전송할 수 있다.

### 규칙
TCP를 이용한 데이터 통신을 할 때 단순히 TCP 패킷만을 캡슐화해서 통신하는 것이 아닌 `페이로드`를 포함한 패킷을 주고 받을 때의 일정한 규칙
- 위의 3-way handshake 에서는 연결 수립 과정으로 단순히 TCP 패킷만 캡슐화 하였다. (페이로드가 포함되지 않은 상태)

1. 보낸 쪽에서 또 보낼 때 SEQ번호와 ACK번호는 그대로다.
2. 받는 쪽에서 SEQ번호 : 받은 ACK 번호가 된다.
3. 받는 쪽에서 ACK번호 :  받은 SEQ번호 + 데이터의 크기(tcp payload)

## 연결 종료 (4-way handshake)

1. 컴퓨터1 에서 컴퓨터2로 연결 종료 요청(FIN)을 보낸다.
   - seq : x, ack : y
2. 컴퓨터2 에서 컴퓨터1로 연결 종료 응답(ACK)을 반환한다.
   - seq : y, ack : x+1 
3. 동시에 컴퓨터2에서도 컴퓨터1로 연결 종료 요청(FIN)을 보낸다.
   - seq: z, ack : x+1
4. 컴퓨터1에서 컴퓨터2로 연결 종료 응답(ACK)을 반환한다.
   - seq: x+1, ack : z+1
> TCP는 신뢰성과 정확성을 중요하게 여기는 프로토콜이다. 연결을 확립할 때 뿐만 아니라, 연결을 종료할 때도 FIN 을 이용하여 확인한다.

- 데이터는 서버로부터 클라이언트로 전달되며, 확인 응답(ACK)은 클라이언트로부터 서버로 전달된다.
- 클라이언트는 더 이상의 데이터를 서버로 전송할 수 없다.
---

## 실제 TCP 패킷 분석

### Basic

### 3-way handshake
![handshake.png](img%2Fhandshake.png)
- 특정 웹 페이지로 접속 시 3-way handshake 가 일어나는 사진

#### SYN 세그먼트
![SYN 세그먼트.png](img%2FSYN%20%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8.png)
- SYN flag 비트가 1로 설정되어 있는 모습(나머지 플래그는 모두 0!)
- 사진엔 없지만 Destination port : 80 으로 설정되어 있다.(HTTP 포트)

#### SYN+ACK 세그먼트
![SYN,ACK 세그먼트.png](img%2FSYN%2CACK%20%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8.png)
- SYN,ACK 플래그가 1로 설정되어있다.

#### ACK 세그먼트
![ACK 세그먼트.png](img%2FACK%20%EC%84%B8%EA%B7%B8%EB%A8%BC%ED%8A%B8.png)
- ACK 플래그 비트가 1로 설정되어있다.

### 연결이 수립된 후 통신 과정